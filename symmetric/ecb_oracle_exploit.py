from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from requests import get
from string import printable


BLOCK_SIZE = 16
# KEY = ?
# FLAG = "crypto{flagflagf}"
# got by try and error on different length of input
FLAG_LEN_BYTES = 25

HOST = lambda plaintext: f'https://aes.cryptohack.org/ecb_oracle/encrypt/{plaintext}/'

def encrypt(plaintext):

	print(HOST(plaintext))
	res = get(HOST(plaintext))
	print(f'{res.content = }')
	return res.json()['ciphertext']

	"""
	plaintext = bytes.fromhex(plaintext)

	padded = pad(plaintext + FLAG.encode(), 16)
	cipher = AES.new(KEY, AES.MODE_ECB)
	try:
		encrypted = cipher.encrypt(padded)
	except ValueError as e:
		return {"error": str(e)}

	return {"ciphertext": encrypted.hex()}
	"""


# built from end
flag = b''

# brute force byte by byte
# i=len(flag)
for i in range(FLAG_LEN_BYTES):
	# 7 * '00' + FLAG_LEN * '00' + enough to push last part to brute-force
	plaintext = '00' * (2 * BLOCK_SIZE - FLAG_LEN_BYTES + i + 1)

	c_flag = encrypt(plaintext)

	for c in printable:
		p_hex = plaintext + '00' * (FLAG_LEN_BYTES - len(flag) - 1) + c.encode().hex() + flag.hex()
		p = pad( bytes.fromhex(p_hex), BLOCK_SIZE ).hex()
		enc = encrypt(p)
		print(f'{c = }\t{p = }\n{c_flag = }\n{enc    = }')
		if c_flag[len(p) - 2 * BLOCK_SIZE * ((i + 1) // BLOCK_SIZE + 1) : len(p)] == enc[len(p) - 2 * BLOCK_SIZE * ((i + 1) // BLOCK_SIZE + 1) : len(p)]:
			flag = c.encode() + flag
			break
	
	print(f'\n\n{flag = }\n\n')

print(flag.decode())
