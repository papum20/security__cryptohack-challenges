from pwn import remote
import json
from datetime import datetime
from sage.all import *
from hashlib import sha1
from Crypto.Util.number import bytes_to_long, inverse
from ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192



# secp192r1
p = 0xfffffffffffffffffffffffffffffffeffffffffffffffff
K = GF(p)
a = K(0xfffffffffffffffffffffffffffffffefffffffffffffffc)
b = K(0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1)
E = EllipticCurve(K, (a, b))
G = E(0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012, 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)
E.set_order(0xffffffffffffffffffffffff99def836146bc9b1b4d22831 * 0x1)

n = E.order()


HOST = "socket.cryptohack.org"
PORT = 13381

rem = remote(HOST, PORT) 


out = rem.recvline()
print(out)

# get values at second 2
seconds = datetime.now().second
while seconds != 2:
	if seconds != datetime.now().second:
		print(datetime.now().time().isoformat())
	seconds = datetime.now().second

rem.sendline(b'{"option": "sign_time"}')
out = rem.recvline()
print(out)
m = json.loads(out)
r = int(m['r'], 16)
s = int(m['s'], 16)
msg = m['msg']
e = bytes_to_long(sha1(msg.encode()).digest())
print(f'{r = }, {s = }, {e = }')


# k is then 1
k = 1
# get dA
dA = ((s * k - e) * inverse(r, n)) % n


# forge signature
m1 = "unlock"
e1 = bytes_to_long(sha1(m1.encode()).digest())

g = generator_192
n = g.order()
pubkey = Public_key(g, g * dA)
privkey = Private_key(pubkey, dA)
sig = privkey.sign(e1, k)

payload = {
	"option": "verify",
	"msg": m1,
	"r": hex(sig.r),
	"s": hex(sig.s)
}
print(f'{payload = }')

rem.sendline(json.dumps(payload))

out = rem.recvline()
print(out)