"""
MOV attack from
https://risencrypto.github.io/WeilMOV/
https://crypto.stackexchange.com/a/1875/115423
"""

from random import randint
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from sage.all import *

from ecc4_decrypt import decrypt_flag



FLAG = b"crypto{??????????????????????????????????????}"

def gen_keypair(G, p):
    n = randint(1, (p-1))
    P = n*G
    return n, P

def gen_shared_secret(P, n):
    S = P*n
    return S.xy()[0]

def encrypt_flag(shared_secret: int):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Encrypt flag
    iv = os.urandom(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(FLAG, 16))
    # Prepare data to send
    data = {}
    data['iv'] = iv.hex()
    data['encrypted_flag'] = ciphertext.hex()
    return data

# Define Curve params
p = 1331169830894825846283645180581
a = -35
b = 98
E = EllipticCurve(GF(p), [a,b])
G = E.gens()[0]

print(f'gens: {E.gens()}')
print(f'order = {E.order()}')
print(f'orders of gens: {[e.order() for e in E.gens()]}')
print(f'{G = }')
print(f'{E.abelian_group() = }')

# Generate keypair
n_a, P1 = gen_keypair(G, p)
n_b, P2 = gen_keypair(G, p)

# Calculate shared secret
S1 = gen_shared_secret(P1, n_b)
S2 = gen_shared_secret(P2, n_a)

# Check protocol works
assert S1 == S2

flag = encrypt_flag(S1)


P1 = E(1110072782478160369250829345256, 800079550745409318906383650948)
P2 = E(1290982289093010194550717223760, 762857612860564354370535420319)
iv = 'eac58c26203c04f68d63dc2c58d79aca'
enc ='bb9ecbd3662d0671fd222ccb07e27b5500f304e3621a6f8e9c815bc8e4e6ee6ebc718ce9ca115cb4e41acb90dbcabb0d'

#print(f'orders of P1,P2: {[p.order() for p in [P1,P2]]}')
#print(type(P1))
#print(help(P1.__mul__))

# minimal gens
print(f'{E.abelian_group().gens() = }')
print(f'{E.gens() = }')
print(f'{factor(E.gens()[0].order()) = }')
print(f'{factor(E.gens()[1].order()) = }')
print(f'{E.defining_polynomial() = }')

#print(f'{[factor(e.order()) for e in E.gens()] = }')
#print(f'{factor(P1.order()) = }')


shared_secret = P1 * prod(factor(E.order()/P2.order()))
print(f'{shared_secret = }')
#print(f'{shared_secret.order() = }')


# small cofactor, vulnerable to MOV attack

print(f'cofactor h = {E.order() / G.order()}')

# embedding degree
k = 1
while (p**k) % G.order() != 1:
    k += 1

print(f'embedding degree k = {k}')


# MOV attack
print('---')
print('--- MOV attack ---')
print('---')

Fpk = GF(p**k)
#F = IntegerModRing(p**k)

print(f'{P1.order() = }')
print(f'{P2.order() = }')
print(f'{G.order() = }')
print(P1.weil_pairing(P2, P1.order()))

# 1) Compute the order of the Elliptic Curve over the Extension field i.e. n=#E(Fqk)
Epk = E.base_extend(Fpk)
#Epk = EllipticCurve(Fpk, [a,b])
Epk.abelian_group()

# Since the m-Torsion group of E(Fq) is a subgroup of E(Fqk), m|n (Lagrange’s Theorem)
m = E.order()
n = Epk.order()
#print(f'{n = }')
#print(f'{m = }')
#print(f'{factor(n) = }')
#print(f'{factor(m) = }')
assert n % m == 0

# 2) Choose a random point T in E(Fqk) such that T not in E(Fq)
z2 = Fpk.gen()  # generator of the extension field
Gpk = Epk.gens()[0]

# Create an element of the extension field
#x = Gpk.xy()[0].list()[1] * z2 + Gpk.xy()[0].list()[0]

print(f'{Gpk = }')
print(f'{G.order() = }')
print(f'{Gpk.order() = }')
print(f'{Gpk.order() / G.order() = }')
print(f'{Epk.lift_x( Gpk.xy()[0] +  Gpk.xy()[0].list()[1] * z2 ) = }')


T = Epk.random_element()
#print(f'before while {T = }')
#i = 0
#while E.is_on_curve(T.xy()[0], T.xy()[1]):
#
#    if i < 10 or int(str(i)[1:]) == 0:
#        print(f'{i = }')
#    i += 1
#
#    T = Epk.random_element()

print(f'{T = }')
#assert not E.is_on_curve(T.xy()[0], T.xy()[1])


# 3) Compute S=(n/m)*T.
# If S=O, then go back to step 2 & chose another random point T
# If it’s not O, then it’s a point of order m

INF = P1 * P1.order()
while T * (n//m) == INF:
    T = Epk.random_element()

print(f'{T = }')


# 4) P,rP in G1, S in G2 : Compute the 2 Weil Pairing values
# u=em(P,S) , v=em(rP,S) , u,v in Fqk
# Since the Weil Pairing is bilinear & r is a scalar, v=em(P,S)^r
# Since u=em(P,S) , we get v=u^r

# This is the Discrete Log problem(DLP) in the multiplicative group of Fqk
# So we have transformed the ECDLP Q=rP into the DLP v=u^r


EpkG = Epk(G.xy()[0], G.xy()[1])
EpkP1 = Epk(P1.xy()[0], P1.xy()[1])

u = T.weil_pairing(EpkG, T.order())
v = T.weil_pairing(EpkP1, T.order())

print(f'{u = }')
print(f'{u.order() = }')
print(f'{v = }')
print(f'{v.order() = }')


# 5) If q^k is not too large, then v=u^r can be solved using Index Calculus
# & r can be found. So we have solved Q=rP

#n_a = v.log(u)
n_a = 29618469991922269

print(f'{n_a = }')

S2 = gen_shared_secret(P2, n_a)

print(f'{S2 = }')


flag = decrypt_flag(S2, iv, enc)

print(f'{flag = }')

print(E.order())
print(Epk.order())
print(G.order())
print(Gpk.order())
print(P1.order())
print(T.order())